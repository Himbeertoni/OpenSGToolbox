//_______________________________________________________________________________________////	TITLE   : polyWeightExport.mel////	AUTHOR	: Robert Bateman////	E-MAIL  : robthebloke@hotmail.com////	DATE    : 30/01/01////	NOTES   : exports polygonal mesh weights to a text file. Allows you//			  to then write a file translator for games or to re-import//			  the weighting data after altering the skeleton.////	USAGE   : run the script.////	INFO    : Will only work for smooth skinned meshs. It will not work//			  if you delete the history of the mesh you wish to export.//			  'polyWeightImport.mel' will re-import the data into maya.//			  Tweaking the mesh after it has been bound will destroy the//			  connections to the weighting info, so dont do it!!!!!//			  errors may occur if there are blend shapes in the scene.//			  This will be rectified soon, not a major problem at the//			  moment, the mesh count will just be out in the file.....////_______________________________________________________________________________________////	Copyright © 2001 Robert Bateman//	All Rights Reserved////	For educational purposes only.//  Please do not republish in electronic or print form without permission//  Thanks - robthebloke@hotmail.com////_______________________________________________________________________________________//___________________________________________________________________ outputMeshInfo()/////////////////////////////////////////////////////////////////////////	Outputs vertex counts for the specified mesh to the given//	file handle//    global string $JointNames[];clear $JointNames;global vector $BoneVectors[];clear $BoneVectors;procint getJointId(string $JointName){	global string $JointNames[];	for($i = 0 ; $i<size($JointNames) ; $i++)	{		if($JointNames[$i] == $JointName)		{			return $i+1;		}	}	return -1;}procint getNextFieldId(  ){   global int $FieldIdSrc;   int $result = $FieldIdSrc;   $FieldIdSrc += 1;   return $result;}proc vector euler2Axis(float $Euler[]){	vector $Result;	float $c[] = {cos(deg_to_rad($Euler[0])/2.0), cos(deg_to_rad($Euler[1])/2.0), cos(deg_to_rad($Euler[2])/2.0)};	float $s[] = {sin(deg_to_rad($Euler[0])/2.0), sin(deg_to_rad($Euler[1])/2.0), sin(deg_to_rad($Euler[2])/2.0)};	$Result = << $s[0]*$s[1]*$c[2] + $c[0]*$c[1]*$s[2],$s[0]*$c[1]*$c[2] + $c[0]*$s[1]*$s[2],$c[0]*$s[1]*$c[2] - $s[0]*$c[1]*$s[2]>>;	unit($Result);	return $Result;}proc float euler2Angle(float $Euler[]){	float $c[] = {cos(deg_to_rad($Euler[0])/2.0), cos(deg_to_rad($Euler[1])/2.0), cos(deg_to_rad($Euler[2])/2.0)};	float $s[] = {sin(deg_to_rad($Euler[0])/2.0), sin(deg_to_rad($Euler[1])/2.0), sin(deg_to_rad($Euler[2])/2.0)};		return 2.0 * acos($c[0]*$c[1]*$c[2] - $s[0]*$s[1]*$s[2]);}proc float[] euler2Quat(float $Euler[]){	float $Result[] = {0.0,0.0,0.0,1.0};		float $c[] = {cos(deg_to_rad($Euler[0])/2.0), cos(deg_to_rad($Euler[1])/2.0), cos(deg_to_rad($Euler[2])/2.0)};	float $s[] = {sin(deg_to_rad($Euler[0])/2.0), sin(deg_to_rad($Euler[1])/2.0), sin(deg_to_rad($Euler[2])/2.0)};	$Result[0] = $s[0]*$s[1]*$c[2] + $c[0]*$c[1]*$s[2];	$Result[1] = $s[0]*$c[1]*$c[2] + $c[0]*$s[1]*$s[2];	$Result[2] = $c[0]*$s[1]*$c[2] - $s[0]*$c[1]*$s[2];	$Result[3] = $c[0]*$c[1]*$c[2] - $s[0]*$s[1]*$s[2];	return $Result;}proc float[] Axis2Quat(vector $Axis, float $AngleRad){	float $Result[] = {0.0,0.0,0.0,1.0};       float $rTmp = $Axis.x*$Axis.x+$Axis.y*$Axis.y+$Axis.z*$Axis.z;	if($rTmp > 0.0001)	{		$rTmp = sin($AngleRad / 2.0) / $rTmp;		$Result[0] =  $Axis.x * $rTmp;		$Result[1] =  $Axis.y * $rTmp;		$Result[2] =  $Axis.z * $rTmp;		$Result[3] =  cos($AngleRad / 2.0);	}	return $Result;}procoutputBoneInfo( string $bone , int $fH ){    global vector $BoneVectors[];    string $parents[] = `listRelatives -p $bone`;    float $position[] = `joint -q -position -r $bone`;    vector $EndPosition = `xform -q -r -t $bone`;    vector $EndPositionNormal = unit($EndPosition);    $BoneVectors[`size $BoneVectors`] = $EndPositionNormal;       //$EndPositionNormal = rot($EndPositionNormal, euler2Axis(`joint -q -orientation $bone`), euler2Angle(`joint -q -orientation $bone`));    vector $Z;    if(size($parents) == 0)    {       $Z = <<0.0,0.0,1.0>>;    }    else    {        $Z = $BoneVectors[getJointId(`joint -q -name $parents[0]`)-1];    }    vector $Axis = cross($Z,$EndPositionNormal);    float $Angle = angle($Z,$EndPositionNormal );    //float $orient[] = euler2Quat(`joint -q -orientation $bone`);    float $orient[] = Axis2Quat($Axis, $Angle);    string $Name = `joint -q -name $bone`;    int    $FieldId = getJointId($Name);    fprint $fH "   <Bone\n     fieldcontainerid=\"";    fprint $fH $FieldId;    fprint $fH "\"\n";    fprint $fH "     nameAttachment=\"";    fprint $fH $Name;    fprint $fH "\"\n";    //string $Export  = "     Translation=\"" + $EndPosition.x + "," +$EndPosition.y + "," +$EndPosition.z + "\"\n";     string $Export  = "     Translation=\"" + 0.0 + "," +0.0 + "," +0.0 + "\"\n";    fprint $fH $Export;    string $ExportO  = "     Rotation=\"" + $orient[0] + " " +$orient[1] + " " +$orient[2] + " " +$orient[3] + "\"\n";     fprint $fH $ExportO;    //float $Length = $EndPosition[0]*$EndPosition[0] + $EndPosition[1]*$EndPosition[1] + $EndPosition[2]*$EndPosition[2];    //$Length = sqrt($Length);    string $Export1  = "     Length=\"" + mag($EndPosition) +  "\"\n";     fprint $fH $Export1;               	if(size($parents)>0)	{		select -add $parents;		for($i=0;$i<size($parents);$i++)		{			int $ParentId = getJointId($parents[$i]);                    fprint  $fH "     InternalParent=\"";                    fprint  $fH $ParentId;                    fprint  $fH "\"\n";                    //string  $Export  = "      " + "List of Attr :" + $list;                     //fprint  $fH $Export;                    //fprint  $fH "\n";		}	}    string $childrens[] = `listRelatives -c $bone`;	if(size($childrens)>0)	{		select -add $childrens;    		string $Export  = "     InternalChildren=\"";		for($i=0;$i<size($childrens);$i++)		{			if(getJointId($childrens[$i]) >= 1)			{		      		if($i!=0)                    		{                    			$Export += ";";                    		}		      		$Export += getJointId($childrens[$i]);			}		}		$Export += "\"\n";              fprint  $fH $Export;	}    fprint $fH "   >\n   </Bone>\n";    }procdecBoneRec( string $bone ){	global string $JointNames[];	$JointNames[`size $JointNames`] = `joint -q -name $bone`;	string $children[] = `listRelatives -c $bone`;	for($i=0 ; $i<size($children) ; $i++)	{		if(`objectType -isType "joint" $children[$i]`)		{			decBoneRec($children[$i]);		}	}}procoutputBoneRec( string $bone , int $fH ){	global string $JointNames[];	$JointNames[`size $JointNames`] = `joint -q -name $bone`;		outputBoneInfo($bone, $fH);	string $children[] = `listRelatives -c $bone`;	for($i=0 ; $i<size($children) ; $i++)	{		if(`objectType -isType "joint" $children[$i]`)		{			outputBoneRec($children[$i], $fH);		}	}}procoutputSkeletonInfo(int $fH ){		string $ExportList[] = `ls -l -type joint`;	for($srfNum=0; $srfNum<size($ExportList); $srfNum++)	{		string $parents[] = `listRelatives -p $ExportList[$srfNum]`;		if(size($parents) == 0)		{			decBoneRec($ExportList[$srfNum]);			outputBoneRec($ExportList[$srfNum], $fH);		}	}}//___________________________________________________________________ polyWeightExport()/////////////////////////////////////////////////////////////////////////	Outputs the skin weighting info to a specified file for all//	bound meshes in the scene. Takes a dummy parameter "$type"//	which is required for the fileBrowser callback, but unused in//	this instance.//proc intpolyWeightExport( string $filename , string $type ){	//	// open file for output	//	$fileId = `fopen $filename "w"`;	//	// Print version number (got quite a few now)	//       fprint $fileId "<?xml version=\"1.0\"?>\n\n<OSGFieldContainers>\n";	//	// get list of meshes in scene	//	string $ExportList[] = `ls -l -type joint`;	//	// get number of surfaces - will not match final output	// (this is a list of all mesh structures in scene, that	//  includes blend shapes + the original bind pose etc..)	//	int $len = size( $ExportList );	// Get out clause if no surfaces are selected	if( $len == 0 )	{		print "No Joints In Scene\nNo Output To File\n";		fclose $fileId;		return 0;	}	//	// Loop Through selected Joints and output data	// to file in given order for a laugh.....	//	outputSkeletonInfo($fileId );       fprint $fileId "</OSGFieldContainers>\n";	fclose $fileId;	return 1;}////	Create file browser dialog to get file name - using best guess, only way//	to get an export dialog......//fileBrowser ( "polyWeightExport" , "Save As" , "Best Guess" , 1 );