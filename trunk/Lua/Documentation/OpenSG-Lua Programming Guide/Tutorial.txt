Lua - OpenSGToolbox 

This will guide you on how to use Lua scripting with OpenSG/OpenSGToolbox.

More specifically, it provides guidance on how to create and manipulate field 
containers with Lua.  Lua can be used to dynamically manipulate field containers
with relative ease.

Starting out:

Before you can manipulate a field container, you must create it or retrieve one
that has already been created.  Here is an example how to create a Blinn 
Material:

local BlinnMat = OSG.getFieldContainer("My Material")
if(not BlinnMat) then
    BlinnMat = OSG.createFieldContainer("BlinnMaterial")
    BlinnMat:setName("My Material")
end

Let's step through this line by line.  The first line 

	local BlinnMat = OSG.getFieldContainer("My Material")
	
is looking for a field container with the name "My Material", and assigning
it to BlinnMat.  In order for "My Material" to be found, it would need to
have been instantiated already, perhaps somewhere else. Since we can't be sure 
if a "Blinn Material" has already been instantited, the second checks whether or
not it was.   

	if(not BlinnMat) then
	
If "My Material" was not found, then the (not BlinnMat) check will be true.  
The next two lines are creating a Blinn Material, and assigning it the name "My
Material".  The line

	BlinnMat = OSG.createFieldContainer("BlinnMaterial")
	
is generating a new field container with of type BlinnMaterial.  

				***NOTE***
	   The type of field container you want to generate MUST 
		   be a valid class of field container!

For example, if you wanted to create a Node, you would use the following:

	local MyNode = OSG.createFieldContainer("Node")
	
The next line of the example

	BlinnMat:setName("My Material")

is naming the BlinnMat "My Material".  Now that it has been created, you will
be able to later retrieve this same material with 
OSG.getFieldContainer("My Material").  

Finally, the 'end' statement is needed after the 'if' statement, so that the
Lua parser knows where the end of the 'if' block is.




Manipulating Field Container Values:
	
Once you have the desired field container created or retrieved, you can start to
manipulate its values.  There are several methods available, and the right one
must be chosen depending on the cardinality of the data (single-value or 
multiple-value), and whether you are retrieving or setting data to that field.

Here is an example, using the BlinnMat demonstrated above:

BlinnMat:setFieldValue("Diffuse", 0.65)

BlinnMat is the name of our variable in question.  The colon designates that we
are calling a function on BlinnMat, and setFieldValue is the function.  The 
argument list for the function, in this case ("Diffuse", 0.65) MUST match the 
cardinality of the field in question, and the field name MUST be a valid field
for that class.  For a Blinn Material, Diffuse has a single
value cardinality (Meaning that there is only one value for the field "Diffuse")
Finally, 0.65 is what we are setting the value to.  

In the case of multi-valued cardinality, you must provide an index for the value
you wish to access or set.

Single Value Fields:
	
	setFieldValue(string FieldName, Value)
	-- Set the value of FieldName to Value
		FieldName: Name of the field name you want to set
		Value: Value for that field
	
	getFieldValue(string FieldName)
	-- Get the value of FieldName
		FieldName: Name of the field you want to retrieve
		
Multiple Value Fields:

	setFieldValue(stirng FieldName, int Index, Value)
	-- Set FieldName[Index] to Value
		FieldName: Name of the field you wish to set
		Index: The index of the value in the field you with to set
		Value: The value which will be set to the field at Index
		
	getFieldValue(string FieldName, int Index)
	-- Gets and returns FieldName[Index]
		FieldName: Name of the field in question
		Index: Index in the field you want to retrieve
		
	pushFieldValue(string FieldName, Value)
	-- Add Value to the end of FieldName
	-- The value will be 'pushed' on to the end of the array/vector
		FieldName: Name of the field to add a value to
		Value: The value that will be added to the end of the Field
		
	insertFieldValue(string FieldName, int Index, Value)
	-- Inserts Value at FieldName[Index], and the values after Index are
	-- pushed back
		FieldName: Name of the field in question
		Index: Position at which Value will be inserted
		Value: Value to be inserted
		
	removeFieldValue(string FieldName, int Index)
	-- removes the value at FieldName[Index] from the field
		FieldName: Name of the field in question
		Index: Index of the value to be removed from the field.
		
	clearField(string FieldName)
	-- Clears the FieldName, effectivly removing all indicies
		FieldName: Field name to clear/reset
		


Values:

There are many types that can be used for field container values.  Some of these
can have their own functions to specifically deal with their internal values, 
while others may be field containers themselves.  Being able to use and fully
manipulate these values is important, so here we will take a look at how do just
that.

Let's start with the basic types.

Numeric types, such as integer values and floating point numbers, can be input
as they are.  Take our earlier example
	BlinnMat:setFieldValue("Diffuse", 0.65)
The value is simply entered as '0.65'.  

Additionaly, any expression that evaluates to the same type as the desired field 
can be used as well, such as this:
	BlinnMat:setFieldValue("Diffuse", 0.05 + 0.6)
would be the same as
	BlinnMat:setFieldValue("Diffuse", 0.65)

OpenSG has a large set of types used to manipulate data such as colors, vectors,
matricies, and coordinate points.  Lua can create and parse these values, as
well as perform operations on them.  The following is a list of the available
types, how to instantiate them, and some of the available operations for them.

				***NOTE***
		This is NOT an exhaustive list of available
		functions for these data types.  For a more
		  complete list, refer to OSGBase.i in the 
		        folder Lua/src/Bindings.

				
				 Points:

Pnt2f: OSG.Pnt2f(1.0,1.0), OSG.Pnt2f(1.0)
-- Two dimensional point value, as a (x,y) coordinate.

Pnt3f: OSG.Pnt3f(1.0,1.0,1.0), OSG.Pnt3f(1.0)
-- Three dimensional point value, as a (x,y,z) coordinate.

Pnt4f  OSG.Pnt4f(1.0,1.0,1.0,1.0), OSG.Pnt4f(1.0)
-- Four dimensional point value, as a (x,y,z,w) coordinate.

Available operations:
Addition, subtraction, multiplication, negation can be performed on points of
the same cardinality. For example, a Pnt2f can be added to a Pnt2f, but not to a
Pnt3f.

				Vectors:

Vec2f: OSG.Vec2f(1.0,1.0), OSG.Vec2f(1.0)
-- Two dimensional euclidian vector value, as a (x,y) direction/magnitude.

Vec3f: OSG.Vec3f(1.0,1.0,1.0), OSG.Vec3f(1.0)
-- Three dimensional euclidian vector value, as a (x,y,z) direction/magnitude. 

Vec4f: OSG.Vec4f(1.0,1.0,1.0,1.0), OSG.Vec4f(1.0)
-- Four dimensional vector value, as a (x,y,z,w) direction/magnitude.

Available operations:
Since vectors are a special subset of points, they have all the functionality
of Points, and some additional functionality, such as dot products,cross
products, and normalization.


				Colors:
				
Color3f: OSG.Color3f(1.0,1.0,1.0)
-- Three channel color, representing red, green, and blue.

Color4f: OSG.Color4f(1.0,1.0,1.0,1.0)
-- Four channel color, representing red, green, blue, and alpha/transparency.


Available operations:
Addition, subtraction, multiplication, and division van be performed on colors
of the same cardinality.  For example, a Color3f can be multiplied by another
Color3f, but not by a Color4f. Operations are performed per component,
i.e. Color3f(0.2,0.3,0.4) + Color3f(0.4,0.0,0.5) = Color3f(0.6,0.3,0.9).


			     Matricies:

Matrix: OSG.Matrix(Vec3f, Vec3f, Vec3f), OSG.Matrix(Vec3f, Vec3f, Vec3f, Vec3f)
(There are many other constructors available)
-- A 4x4 matrix of values that represents translation, rotation, and scaling

Avalabe operations:
Addition, subtraction, and scalar multiplication can all be performed per 
component. Also, there are many operations for finding transpose forms, inverse 
forms, determinants, matrix multiplications, factoring, and others.

			    Quaternions:

Quaternion: OSG.Quaternion(Vec3f axis, Real32 angle), OSG.Quaternion(Vec3f
rotateFrom, Vec3f rotateTo), others are available

-- Represents a rotation in 3 dimensional space.

Available operations:
Normalization, inversion, scalar multiplication, spherical interpolation between
two quaternions, quaternion multiplication, and others.



